name: Security Scans

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry mode (no deployments)'
        type: boolean
        required: true
        default: true
    
jobs:
  security-scans-and-build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write # Required for CodeQL and secret scanning
      id-token: write # Required for AWS OIDC authentication

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2.a GitHub Secret Scan
      - name: GitHub Secret Scan
        uses: actions/checkout@v4
      # Note: GitHub secret scanning runs automatically for public repositories and requires GitHub Advanced Security for private ones.

      # 2.b SAST scan by CodeQL
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
           languages: javascript-typescript # Specify relevant languages
           # queries: security-extended, security-and-quality
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

      # Setup JFrog CLI for SCA and Container scans
      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4.8.1
        with:
          # Use OIDC for authentication (recommended)
          oidc-provider-name: ${{ secrets.JFROG_OIDC_PROVIDER_NAME }}
          oidc-audience: ${{ secrets.JFROG_OIDC_AUDIENCE }}
        env:
          # JF_URL and JF_PROJECT should be configured as GitHub secrets or variables
          JF_URL: ${{ vars.JF_URL }} 
          JF_PROJECT: ${{ vars.JF_PROJECT }}

      # 2.c SCA scan by Jfrog Xray
      # This can be run on source code or after build
      - name: Run JFrog Xray SCA scan on source
        run: |
          jf c add my-jfrog-server --url ${{ secrets.JFROG_URL }} --user ${{ secrets.JFROG_USER }} --password ${{ secrets.JFROG_PASSWORD }} --interactive=false
          jf scan . 

      # 3. Build Artifact (assuming a simple app, e.g., Node.js)
      - name: Build Application Artifact
        run: |
          # Replace with your actual build command (e.g., npm install, make build)
          echo "Building application..."

      # 4. Unit test need to add by application team



      # 4. Create docker image
      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.JFROG_REGISTRY_URL }}/${{ vars.JF_PROJECT }}/my-app:${{ github.run_number }} .
         
      # 5. Push image to jfrog
      - name: Log in to JFrog Artifactory Docker Registry
        run: |
          jf rt docker login ${{ secrets.JFROG_REGISTRY_URL }} --user ${{ secrets.JFROG_USER }} --password ${{ secrets.JFROG_ACCESS_TOKEN }}

      - name: Push Docker image to Artifactory
        run: |
          jf rt docker push ${{ secrets.JFROG_REGISTRY_URL }}/${{ vars.JF_PROJECT }}/my-app:${{ github.run_number }} --build-name=my-app --build-number=${{ github.run_number }}

      # 2.d Container scan by jfrog
      - name: Scan Docker image with Xray
        run: |
          jf rt build-docker-create my-app ${{ github.run_number }}
          jf rt build-scan my-app ${{ github.run_number }}
          jf rt build-publish my-app ${{ github.run_number }} # Publish build info to Artifactory
