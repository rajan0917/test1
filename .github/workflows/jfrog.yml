name: Deploy Helm to EKS with Security Scans

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry mode (no deployments)'
        type: boolean
        required: true
        default: true
    
jobs:
  security-scans-and-build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write # Required for CodeQL and secret scanning
      id-token: write # Required for AWS OIDC authentication

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2.a GitHub Secret Scan
      - name: GitHub Secret Scan
        uses: actions/checkout@v4
      # Note: GitHub secret scanning runs automatically for public repositories and requires GitHub Advanced Security for private ones.

      # 2.b SAST scan by CodeQL
#      - name: Initialize CodeQL
#        uses: github/codeql-action/init@v3
#        with:
#          languages: javascript-typescript # Specify relevant languages
#          # queries: security-extended, security-and-quality
#      - name: Perform CodeQL Analysis
#        uses: github/codeql-action/analyze@v3

      # Setup JFrog CLI for SCA and Container scans
      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4.8.1
        with:
          # Use OIDC for authentication (recommended)
          oidc-provider-name: ${{ secrets.JFROG_OIDC_PROVIDER_NAME }}
          oidc-audience: ${{ secrets.JFROG_OIDC_AUDIENCE }}
        env:
          # JF_URL and JF_PROJECT should be configured as GitHub secrets or variables
          JF_URL: ${{ vars.JF_URL }} 
          JF_PROJECT: ${{ vars.JF_PROJECT }}

      # 2.c SCA scan by Jfrog Xray
      # This can be run on source code or after build
      - name: Run JFrog Xray SCA scan on source
        run: |
          jf scan . 

      # 3. Build Artifact (assuming a simple app, e.g., Node.js)
      - name: Build Application Artifact
        run: |
          # Replace with your actual build command (e.g., npm install, make build)
          echo "Building application..."

      # 4. Unit test need to add by application team



      # 4. Create docker image
      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.JFROG_REGISTRY_URL }}/${{ vars.JF_PROJECT }}/my-app:${{ github.run_number }} .

      # 5. Push image to jfrog
      - name: Log in to JFrog Artifactory Docker Registry
        run: |
          jf rt docker login ${{ secrets.JFROG_REGISTRY_URL }} --user ${{ secrets.JFROG_USER }} --password ${{ secrets.JFROG_ACCESS_TOKEN }}

      - name: Push Docker image to Artifactory
        run: |
          jf rt docker push ${{ secrets.JFROG_REGISTRY_URL }}/${{ vars.JF_PROJECT }}/my-app:${{ github.run_number }} --build-name=my-app --build-number=${{ github.run_number }}

      # 2.d Container scan by jfrog
      - name: Scan Docker image with Xray
        run: |
          jf rt build-docker-create my-app ${{ github.run_number }}
          jf rt build-scan my-app ${{ github.run_number }}
          jf rt build-publish my-app ${{ github.run_number }} # Publish build info to Artifactory
          
  deploy:
    needs: security-scans-and-build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write # Required for AWS OIDC

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Configure AWS Credentials for EKS access
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 6. Create helm chart (or use existing one)
      # Assuming a Helm chart exists in a 'helm/' directory
      - name: Update Helm chart image tag
        run: |
          # Use sed to replace the image tag dynamically in values.yaml
          # Ensure your values.yaml has a placeholder like 'repository: your-repo/your-image' and 'tag: latest'
          sed -i "s|tag: latest|tag: ${{ github.run_number }}|g" ./helm/values.yaml

      # 7. DAST scan Qualys (This is typically run *after* deployment on a running application, so it's placed after deployment in the logical flow, but can be a separate job/workflow)
      # This step requires the application to be accessible via a URL.
      # You would use a Qualys GitHub action for Web Application Scanning here.
      # e.g., uses: Qualys/github_action_qwas@main

      # 8. Deploy to EKS using Helm
      - name: Deploy Helm chart to EKS cluster
        uses: bitovi/github-actions-deploy-eks-helm@v1.2.4 # Community action to simplify deployment
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # Alternative auth method if OIDC is not fully configured for this action
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          cluster-name: ${{ secrets.EKS_CLUSTER_NAME }}
          chart-path: ./helm
          namespace: default
          name: my-app-release
          # values: image.tag=${{ github.run_number }} # Alternative way to pass the tag
